// src/data/modifierTiers.ts - Modifier tier data types and loading
//
// This module provides tier information for item modifiers (affixes).
// Tier 1 is the BEST tier (highest ilvl requirement, highest values).
// Data is loaded from data/modifier_tiers.json (generated by scripts/parse_poe2db.py)

// =========================================================================
// TYPES
// =========================================================================

export interface ModifierTierEntry {
  tier: number;      // 1 = best (highest ilvl)
  name: string;      // Tier name, e.g., "of Tzteosh"
  ilvl: number;      // Required item level
  min: number;       // Minimum roll value
  max: number;       // Maximum roll value
}

export interface ModifierData {
  id: string;                    // e.g., "explicit.strength"
  name: string;                  // Family name, e.g., "Strength"
  textPattern: string;           // e.g., "# to Strength"
  itemClasses: string[];         // Item types this appears on
  tiers: ModifierTierEntry[];    // Tier list, sorted T1-first
  category: ModifierCategory;    // life, damage, resistance, etc.
  isPrefix: boolean;             // true if prefix, false if suffix
  tags: string[];                // Additional tags from poe2db
}

export type ModifierCategory =
  | "life"
  | "mana"
  | "resistance"
  | "attribute"
  | "defense"
  | "damage"
  | "critical"
  | "speed"
  | "accuracy"
  | "other";

export interface ModifierTierData {
  modifiers: ModifierData[];
  version: string;
  lastUpdated: string;
  source: string;
}

// =========================================================================
// TIER INFO RESULT
// =========================================================================

export interface TierMatchResult {
  modifier: ModifierData;        // The matched modifier
  matchedTier: number;           // Which tier the value falls into (1 = best)
  totalTiers: number;            // Total number of tiers for this mod
  tierPercent: number;           // 0-100, how good is this roll (100 = perfect T1)
  rollPercent: number;           // 0-100, how good is the roll within the tier
  tierEntry: ModifierTierEntry;  // Details of the matched tier
}

// =========================================================================
// DATA LOADING
// =========================================================================

// Cache for loaded tier data
let cachedTierData: ModifierTierData | null = null;
let tierPatternIndex: Map<string, ModifierData> | null = null;

/**
 * Load modifier tier data from JSON
 * In the browser/Decky context, this should be called with pre-loaded data
 */
export function loadModifierTierData(data: ModifierTierData): void {
  cachedTierData = data;
  tierPatternIndex = buildPatternIndex(data.modifiers);
}

/**
 * Check if tier data is loaded
 */
export function isTierDataLoaded(): boolean {
  return cachedTierData !== null;
}

/**
 * Get all loaded modifiers
 */
export function getAllModifiers(): ModifierData[] {
  return cachedTierData?.modifiers || [];
}

/**
 * Build an index of normalized text patterns for fast lookup
 */
function buildPatternIndex(modifiers: ModifierData[]): Map<string, ModifierData> {
  const index = new Map<string, ModifierData>();

  for (const mod of modifiers) {
    // Normalize pattern for matching
    const normalized = normalizePattern(mod.textPattern);
    index.set(normalized, mod);

    // Also index by name (lowercase)
    const nameLower = mod.name.toLowerCase();
    if (!index.has(nameLower)) {
      index.set(nameLower, mod);
    }
  }

  return index;
}

/**
 * Normalize a pattern string for matching
 */
function normalizePattern(pattern: string): string {
  return pattern
    .toLowerCase()
    .replace(/[+\-]?#/g, "#")
    .replace(/%/g, "")
    .replace(/\s+/g, " ")
    .trim();
}

/**
 * Normalize modifier text for matching against patterns
 */
export function normalizeModifierText(text: string): string {
  return text
    .toLowerCase()
    .replace(/[+\-]?\d+(?:\.\d+)?/g, "#")
    .replace(/%/g, "")
    .replace(/\s+/g, " ")
    .trim();
}

// =========================================================================
// TIER MATCHING
// =========================================================================

/**
 * Find modifier data by text pattern
 */
export function findModifierByPattern(modifierText: string): ModifierData | null {
  if (!tierPatternIndex) return null;

  const normalized = normalizeModifierText(modifierText);

  // Try exact match first
  if (tierPatternIndex.has(normalized)) {
    return tierPatternIndex.get(normalized) || null;
  }

  // Try partial matching for modifiers with additional text
  for (const [pattern, mod] of tierPatternIndex.entries()) {
    if (normalized.includes(pattern) || pattern.includes(normalized)) {
      return mod;
    }
  }

  // Try matching by keywords
  for (const mod of cachedTierData?.modifiers || []) {
    const modNameLower = mod.name.toLowerCase();
    if (normalized.includes(modNameLower)) {
      return mod;
    }
  }

  return null;
}

/**
 * Extract numeric values from modifier text
 */
export function extractValues(text: string): number[] {
  const values: number[] = [];
  const pattern = /[+\-]?(\d+(?:\.\d+)?)/g;
  let match;

  while ((match = pattern.exec(text)) !== null) {
    values.push(parseFloat(match[1]));
  }

  return values;
}

/**
 * Find which tier a value falls into for a given modifier
 */
export function findTierForValue(
  modifier: ModifierData,
  value: number
): TierMatchResult | null {
  const tiers = modifier.tiers;
  if (!tiers || tiers.length === 0) return null;

  // Find the tier where value falls within min-max range
  for (const tier of tiers) {
    if (value >= tier.min && value <= tier.max) {
      // Calculate roll percent within the tier
      const range = tier.max - tier.min;
      const rollPercent = range > 0
        ? Math.round(((value - tier.min) / range) * 100)
        : 100;

      // Calculate tier percent (T1 = 100%, last tier = lower)
      const tierPercent = Math.round(
        ((tiers.length - tier.tier + 1) / tiers.length) * 100
      );

      return {
        modifier,
        matchedTier: tier.tier,
        totalTiers: tiers.length,
        tierPercent,
        rollPercent,
        tierEntry: tier,
      };
    }
  }

  // Value might be above T1 max or below last tier min
  // Find closest tier
  const bestTier = tiers[0];
  const worstTier = tiers[tiers.length - 1];

  if (value > bestTier.max) {
    // Above T1 max - treat as perfect T1
    return {
      modifier,
      matchedTier: 1,
      totalTiers: tiers.length,
      tierPercent: 100,
      rollPercent: 100,
      tierEntry: bestTier,
    };
  }

  if (value < worstTier.min) {
    // Below worst tier - still match to worst tier
    return {
      modifier,
      matchedTier: tiers.length,
      totalTiers: tiers.length,
      tierPercent: 0,
      rollPercent: 0,
      tierEntry: worstTier,
    };
  }

  return null;
}

/**
 * Match modifier text to tier data
 * This is the main function to use for tier matching
 */
export function matchModifierToTier(modifierText: string): TierMatchResult | null {
  const modifier = findModifierByPattern(modifierText);
  if (!modifier) return null;

  const values = extractValues(modifierText);
  if (values.length === 0) return null;

  // Use primary value (first numeric value in text)
  const primaryValue = values[0];

  return findTierForValue(modifier, primaryValue);
}

// =========================================================================
// UTILITY FUNCTIONS
// =========================================================================

/**
 * Get tier color based on tier number and total tiers
 * Returns CSS color string
 */
export function getTierColor(tier: number, totalTiers: number): string {
  // T1-T2: Green (best)
  // T3-T4: Yellow (good)
  // T5+: Gray (lower)

  if (tier <= 2) {
    return tier === 1 ? "#40c057" : "#69db7c"; // Green shades
  }
  if (tier <= 4) {
    return tier === 3 ? "#fab005" : "#fcc419"; // Yellow shades
  }
  return "#868e96"; // Gray for T5+
}

/**
 * Get tier label for display
 */
export function getTierLabel(tier: number): string {
  return `T${tier}`;
}

/**
 * Get tier description based on quality
 */
export function getTierDescription(tier: number, totalTiers: number): string {
  if (tier === 1) return "Best tier";
  if (tier === 2) return "Excellent";
  if (tier <= Math.ceil(totalTiers / 3)) return "Good";
  if (tier <= Math.ceil((totalTiers * 2) / 3)) return "Average";
  return "Low tier";
}

/**
 * Get category icon/emoji for display
 */
export function getCategoryIcon(category: ModifierCategory): string {
  const icons: Record<ModifierCategory, string> = {
    life: "‚ù§Ô∏è",
    mana: "üíß",
    resistance: "üõ°Ô∏è",
    attribute: "üí™",
    defense: "üî∞",
    damage: "‚öîÔ∏è",
    critical: "üí•",
    speed: "‚ö°",
    accuracy: "üéØ",
    other: "‚ú®",
  };
  return icons[category] || "‚ú®";
}

// =========================================================================
// ITEM CLASS VALIDATION
// =========================================================================

/**
 * Mapping of common item class names to normalized forms
 */
const ITEM_CLASS_ALIASES: Record<string, string[]> = {
  "body armour": ["body armour", "body armours", "body armor", "body armors", "chest"],
  "helmet": ["helmet", "helmets", "helm", "helms"],
  "gloves": ["gloves", "glove", "gauntlets"],
  "boots": ["boots", "boot"],
  "belt": ["belt", "belts"],
  "ring": ["ring", "rings"],
  "amulet": ["amulet", "amulets"],
  "shield": ["shield", "shields"],
  "quiver": ["quiver", "quivers"],
  "one hand sword": ["one hand sword", "one handed sword", "one-handed sword", "sword"],
  "two hand sword": ["two hand sword", "two handed sword", "two-handed sword"],
  "one hand axe": ["one hand axe", "one handed axe", "one-handed axe", "axe"],
  "two hand axe": ["two hand axe", "two handed axe", "two-handed axe"],
  "one hand mace": ["one hand mace", "one handed mace", "one-handed mace", "mace"],
  "two hand mace": ["two hand mace", "two handed mace", "two-handed mace"],
  "bow": ["bow", "bows"],
  "crossbow": ["crossbow", "crossbows"],
  "staff": ["staff", "staves", "staffs"],
  "wand": ["wand", "wands"],
  "sceptre": ["sceptre", "sceptres", "scepter", "scepters"],
  "claw": ["claw", "claws"],
  "dagger": ["dagger", "daggers"],
  "flail": ["flail", "flails"],
  "spear": ["spear", "spears"],
  "quarterstaff": ["quarterstaff", "quarterstaves", "quarterstaffs"],
  "focus": ["focus", "foci", "focuses"],
};

/**
 * Normalize an item class name for comparison
 */
function normalizeItemClass(itemClass: string): string {
  const lower = itemClass.toLowerCase().trim();

  // Check aliases
  for (const [normalized, aliases] of Object.entries(ITEM_CLASS_ALIASES)) {
    if (aliases.includes(lower)) {
      return normalized;
    }
  }

  return lower;
}

/**
 * Check if a modifier can appear on a given item class
 *
 * @param modifier - The modifier data from tier matching
 * @param itemClass - The item class to check against
 * @returns Object with validation result and details
 */
export interface ModifierValidation {
  isValid: boolean;
  canAppearOn: string[];  // Item classes this mod can appear on
  warning?: string;       // Warning message if invalid
}

export function validateModifierForItemClass(
  modifier: ModifierData | null,
  itemClass: string
): ModifierValidation {
  // If no modifier data, assume valid (can't validate)
  if (!modifier) {
    return { isValid: true, canAppearOn: [] };
  }

  // If no itemClasses specified, assume can appear anywhere
  if (!modifier.itemClasses || modifier.itemClasses.length === 0) {
    return { isValid: true, canAppearOn: [] };
  }

  const normalizedItemClass = normalizeItemClass(itemClass);
  const normalizedAllowed = modifier.itemClasses.map(ic => normalizeItemClass(ic));

  // Check if the item class is in the allowed list
  const isValid = normalizedAllowed.includes(normalizedItemClass);

  if (!isValid) {
    return {
      isValid: false,
      canAppearOn: modifier.itemClasses,
      warning: `This mod can only appear on: ${modifier.itemClasses.slice(0, 3).join(", ")}${modifier.itemClasses.length > 3 ? "..." : ""}`,
    };
  }

  return { isValid: true, canAppearOn: modifier.itemClasses };
}

/**
 * Validate a modifier text against an item class
 * Convenience function that combines pattern matching and validation
 */
export function validateModifierText(
  modifierText: string,
  itemClass: string
): ModifierValidation {
  const modifier = findModifierByPattern(modifierText);
  return validateModifierForItemClass(modifier, itemClass);
}
