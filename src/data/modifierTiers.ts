// src/data/modifierTiers.ts - Modifier tier data types and loading
//
// This module provides tier information for item modifiers (affixes).
// Tier 1 is the BEST tier (highest ilvl requirement, highest values).
// Data is loaded from data/modifier_tiers.json (generated by scripts/parse_poe2db.py)

// =========================================================================
// TYPES
// =========================================================================

export interface ModifierTierEntry {
  tier: number;      // 1 = best (highest ilvl)
  name: string;      // Tier name, e.g., "of Tzteosh"
  ilvl: number;      // Required item level
  min: number;       // Minimum roll value
  max: number;       // Maximum roll value
}

export interface ModifierData {
  id: string;                    // e.g., "explicit.strength"
  name: string;                  // Family name, e.g., "Strength"
  textPattern: string;           // e.g., "# to Strength"
  itemClasses: string[];         // Item types this appears on
  tiers: ModifierTierEntry[];    // Tier list, sorted T1-first
  category: ModifierCategory;    // life, damage, resistance, etc.
  isPrefix: boolean;             // true if prefix, false if suffix
  tags: string[];                // Additional tags from poe2db
}

export type ModifierCategory =
  | "life"
  | "mana"
  | "resistance"
  | "attribute"
  | "defense"
  | "damage"
  | "critical"
  | "speed"
  | "accuracy"
  | "other";

export interface ModifierTierData {
  modifiers: ModifierData[];
  version: string;
  lastUpdated: string;
  source: string;
}

// =========================================================================
// TIER INFO RESULT
// =========================================================================

export interface TierMatchResult {
  modifier: ModifierData;        // The matched modifier
  matchedTier: number;           // Which tier the value falls into (1 = best)
  totalTiers: number;            // Total number of tiers for this mod
  tierPercent: number;           // 0-100, how good is this roll (100 = perfect T1)
  rollPercent: number;           // 0-100, how good is the roll within the tier
  tierEntry: ModifierTierEntry;  // Details of the matched tier
}

// =========================================================================
// DATA LOADING
// =========================================================================

// Cache for loaded tier data
let cachedTierData: ModifierTierData | null = null;
let tierPatternIndex: Map<string, ModifierData> | null = null;

/**
 * Load modifier tier data from JSON
 * In the browser/Decky context, this should be called with pre-loaded data
 */
export function loadModifierTierData(data: ModifierTierData): void {
  cachedTierData = data;
  tierPatternIndex = buildPatternIndex(data.modifiers);
}

/**
 * Check if tier data is loaded
 */
export function isTierDataLoaded(): boolean {
  return cachedTierData !== null;
}

/**
 * Get all loaded modifiers
 */
export function getAllModifiers(): ModifierData[] {
  return cachedTierData?.modifiers || [];
}

/**
 * Build an index of normalized text patterns for fast lookup
 */
function buildPatternIndex(modifiers: ModifierData[]): Map<string, ModifierData> {
  const index = new Map<string, ModifierData>();

  for (const mod of modifiers) {
    // Normalize pattern for matching
    const normalized = normalizePattern(mod.textPattern);
    index.set(normalized, mod);

    // Also index by name (lowercase)
    const nameLower = mod.name.toLowerCase();
    if (!index.has(nameLower)) {
      index.set(nameLower, mod);
    }
  }

  return index;
}

/**
 * Normalize a pattern string for matching
 */
function normalizePattern(pattern: string): string {
  return pattern
    .toLowerCase()
    .replace(/[+\-]?#/g, "#")
    .replace(/%/g, "")
    .replace(/\s+/g, " ")
    .trim();
}

/**
 * Normalize modifier text for matching against patterns
 */
export function normalizeModifierText(text: string): string {
  return text
    .toLowerCase()
    .replace(/[+\-]?\d+(?:\.\d+)?/g, "#")
    .replace(/%/g, "")
    .replace(/\s+/g, " ")
    .trim();
}

// =========================================================================
// TIER MATCHING
// =========================================================================

/**
 * Find modifier data by text pattern
 */
export function findModifierByPattern(modifierText: string): ModifierData | null {
  if (!tierPatternIndex) return null;

  const normalized = normalizeModifierText(modifierText);

  // Try exact match first
  if (tierPatternIndex.has(normalized)) {
    return tierPatternIndex.get(normalized) || null;
  }

  // Try partial matching for modifiers with additional text
  for (const [pattern, mod] of tierPatternIndex.entries()) {
    if (normalized.includes(pattern) || pattern.includes(normalized)) {
      return mod;
    }
  }

  // Try matching by keywords
  for (const mod of cachedTierData?.modifiers || []) {
    const modNameLower = mod.name.toLowerCase();
    if (normalized.includes(modNameLower)) {
      return mod;
    }
  }

  return null;
}

/**
 * Extract numeric values from modifier text
 */
export function extractValues(text: string): number[] {
  const values: number[] = [];
  const pattern = /[+\-]?(\d+(?:\.\d+)?)/g;
  let match;

  while ((match = pattern.exec(text)) !== null) {
    values.push(parseFloat(match[1]));
  }

  return values;
}

/**
 * Find which tier a value falls into for a given modifier
 */
export function findTierForValue(
  modifier: ModifierData,
  value: number
): TierMatchResult | null {
  const tiers = modifier.tiers;
  if (!tiers || tiers.length === 0) return null;

  // Find the tier where value falls within min-max range
  for (const tier of tiers) {
    if (value >= tier.min && value <= tier.max) {
      // Calculate roll percent within the tier
      const range = tier.max - tier.min;
      const rollPercent = range > 0
        ? Math.round(((value - tier.min) / range) * 100)
        : 100;

      // Calculate tier percent (T1 = 100%, last tier = lower)
      const tierPercent = Math.round(
        ((tiers.length - tier.tier + 1) / tiers.length) * 100
      );

      return {
        modifier,
        matchedTier: tier.tier,
        totalTiers: tiers.length,
        tierPercent,
        rollPercent,
        tierEntry: tier,
      };
    }
  }

  // Value might be above T1 max or below last tier min
  // Find closest tier
  const bestTier = tiers[0];
  const worstTier = tiers[tiers.length - 1];

  if (value > bestTier.max) {
    // Above T1 max - treat as perfect T1
    return {
      modifier,
      matchedTier: 1,
      totalTiers: tiers.length,
      tierPercent: 100,
      rollPercent: 100,
      tierEntry: bestTier,
    };
  }

  if (value < worstTier.min) {
    // Below worst tier - still match to worst tier
    return {
      modifier,
      matchedTier: tiers.length,
      totalTiers: tiers.length,
      tierPercent: 0,
      rollPercent: 0,
      tierEntry: worstTier,
    };
  }

  return null;
}

/**
 * Match modifier text to tier data
 * This is the main function to use for tier matching
 */
export function matchModifierToTier(modifierText: string): TierMatchResult | null {
  const modifier = findModifierByPattern(modifierText);
  if (!modifier) return null;

  const values = extractValues(modifierText);
  if (values.length === 0) return null;

  // Use primary value (first numeric value in text)
  const primaryValue = values[0];

  return findTierForValue(modifier, primaryValue);
}

// =========================================================================
// UTILITY FUNCTIONS
// =========================================================================

/**
 * Get tier color based on tier number and total tiers
 * Returns CSS color string
 */
export function getTierColor(tier: number, totalTiers: number): string {
  // T1-T2: Green (best)
  // T3-T4: Yellow (good)
  // T5+: Gray (lower)

  if (tier <= 2) {
    return tier === 1 ? "#40c057" : "#69db7c"; // Green shades
  }
  if (tier <= 4) {
    return tier === 3 ? "#fab005" : "#fcc419"; // Yellow shades
  }
  return "#868e96"; // Gray for T5+
}

/**
 * Get tier label for display
 */
export function getTierLabel(tier: number): string {
  return `T${tier}`;
}

/**
 * Get tier description based on quality
 */
export function getTierDescription(tier: number, totalTiers: number): string {
  if (tier === 1) return "Best tier";
  if (tier === 2) return "Excellent";
  if (tier <= Math.ceil(totalTiers / 3)) return "Good";
  if (tier <= Math.ceil((totalTiers * 2) / 3)) return "Average";
  return "Low tier";
}

/**
 * Get category icon/emoji for display
 */
export function getCategoryIcon(category: ModifierCategory): string {
  const icons: Record<ModifierCategory, string> = {
    life: "‚ù§Ô∏è",
    mana: "üíß",
    resistance: "üõ°Ô∏è",
    attribute: "üí™",
    defense: "üî∞",
    damage: "‚öîÔ∏è",
    critical: "üí•",
    speed: "‚ö°",
    accuracy: "üéØ",
    other: "‚ú®",
  };
  return icons[category] || "‚ú®";
}
